# @Observable vs ObservableObject - なぜスローになるのか？

## 📚 目次
1. [基本的な違い](#基本的な違い)
2. [変更検知の仕組み](#変更検知の仕組み)
3. [配列の更新方法の違い](#配列の更新方法の違い)
4. [パフォーマンスへの影響](#パフォーマンスへの影響)
5. [なぜスローになるのか？](#なぜスローになるのか)

---

## 基本的な違い

### ObservableObject + @Published（旧方式）

```swift
class ConfettiViewModel: ObservableObject {
    @Published var particles: [ConfettiParticle] = []
}
```

**特徴：**
- `Combine`フレームワークを使用
- `@Published`プロパティラッパーで変更を検知
- 配列の要素を直接変更しても検知される

### @Observable（新方式）

```swift
@Observable
class ConfettiViewModel {
    var particles: [ConfettiParticle] = []
}
```

**特徴：**
- `Combine`フレームワークが不要
- マクロで自動的に変更検知を実装
- 配列の要素を直接変更しても検知されない（配列全体の再代入が必要）

---

## 変更検知の仕組み

### ObservableObject + @Published の場合

```
配列の要素を変更
  ↓
@Publishedが変更を検知
  ↓
ビューが自動的に更新される
```

**例：**
```swift
particles[0].position.x = 100  // 要素を直接変更
// → @Publishedが検知してビューを更新
```

### @Observable の場合

```
配列の要素を変更
  ↓
変更が検知されない（要素の変更は追跡されない）
  ↓
配列全体を再代入する必要がある
  ↓
ビューが更新される
```

**例：**
```swift
particles[0].position.x = 100  // 要素を直接変更
// → 変更が検知されない！

particles = newParticles  // 配列全体を再代入
// → これで初めて変更が検知される
```

---

## 配列の更新方法の違い

### ObservableObject + @Published の場合

```swift
// パーティクルを更新
for i in particles.indices {
    var particle = particles[i]
    
    // 位置を更新
    particle.position.x += 10
    particle.position.y += 5
    
    // 要素を直接変更（これでOK）
    particles[i] = particle
}

// 透明度が0になったものを削除
particles.removeAll { $0.opacity <= 0 }
```

**何が起こっているか：**
- 配列の要素を直接変更しているだけ
- メモリ効率が良い
- 100個のパーティクルを1つずつ更新

### @Observable の場合

```swift
// パーティクルを更新
var updatedParticles: [ConfettiParticle] = []  // 新しい空の配列を作成

for i in particles.indices {
    var particle = particles[i]
    
    // 位置を更新
    particle.position.x += 10
    particle.position.y += 5
    
    // 新しい配列に追加
    updatedParticles.append(particle)
}

// 配列全体を再代入（これで初めて変更が検知される）
particles = updatedParticles
```

**何が起こっているか：**
- 毎フレーム、100個のパーティクルを新しい配列にコピー
- メモリ効率が悪い
- 古い配列は破棄される

---

## パフォーマンスへの影響

### 1秒間で何が起こるか？

**60FPS（1秒間に60回更新）の場合：**

#### ObservableObject + @Published

```
フレーム1: 100個のパーティクルを更新（要素を直接変更）
フレーム2: 100個のパーティクルを更新（要素を直接変更）
フレーム3: 100個のパーティクルを更新（要素を直接変更）
...
フレーム60: 100個のパーティクルを更新（要素を直接変更）

合計: 6,000回の要素更新
```

**メモリ使用量：**
- 配列は1つだけ（既存の配列を再利用）
- メモリ割り当て：最小限

#### @Observable

```
フレーム1: 100個のパーティクルを新しい配列にコピー → 配列を再代入
フレーム2: 100個のパーティクルを新しい配列にコピー → 配列を再代入
フレーム3: 100個のパーティクルを新しい配列にコピー → 配列を再代入
...
フレーム60: 100個のパーティクルを新しい配列にコピー → 配列を再代入

合計: 6,000回の要素コピー + 60回の配列作成
```

**メモリ使用量：**
- 毎フレーム新しい配列を作成
- 古い配列は破棄される（ガベージコレクションが必要）
- メモリ割り当て：60回/秒

---

## なぜスローになるのか？

### メモリ割り当てのオーバーヘッド

**ObservableObject + @Published:**
```
メモリ割り当て: ほぼゼロ（既存の配列を再利用）
処理時間: 短い
```

**@Observable:**
```
メモリ割り当て: 60回/秒（毎フレーム新しい配列を作成）
処理時間: 長い（メモリ割り当て + コピー処理）
```

### 具体的な処理の流れ

#### ObservableObject + @Published（速い）

```
1. パーティクル1の位置を更新 → メモリ内の値を直接変更
2. パーティクル2の位置を更新 → メモリ内の値を直接変更
3. ...
4. パーティクル100の位置を更新 → メモリ内の値を直接変更
5. ビューが更新される

処理時間: 約0.001秒（1ミリ秒）
```

#### @Observable（遅い）

```
1. 新しい空の配列を作成 → メモリ割り当て（時間がかかる）
2. パーティクル1をコピーして新しい配列に追加 → メモリコピー
3. パーティクル2をコピーして新しい配列に追加 → メモリコピー
4. ...
5. パーティクル100をコピーして新しい配列に追加 → メモリコピー
6. 古い配列を破棄 → ガベージコレクション（時間がかかる）
7. 新しい配列を代入 → ビューが更新される

処理時間: 約0.016秒（16ミリ秒）
```

### なぜこの差が生まれるのか？

#### 1. メモリ割り当てのコスト

**ObservableObject:**
- 既存のメモリ領域を使用
- 新しいメモリを確保する必要がない
- 高速

**@Observable:**
- 毎フレーム新しいメモリ領域を確保
- メモリ割り当ては重い処理
- 遅い

#### 2. データコピーのコスト

**ObservableObject:**
- 要素を直接変更（コピー不要）
- 100個のパーティクルを1つずつ更新

**@Observable:**
- 100個のパーティクルをすべてコピー
- 各パーティクルは約10個のプロパティを持つ
- 合計1,000個の値をコピー（毎フレーム）

#### 3. ガベージコレクションのコスト

**ObservableObject:**
- 古いデータを破棄する必要がない
- ガベージコレクションの負荷が少ない

**@Observable:**
- 毎フレーム古い配列を破棄
- ガベージコレクションが頻繁に発生
- CPUに負荷がかかる

---

## 視覚的な比較

### ObservableObject + @Published（速い）

```
既存の配列: [パ1, パ2, パ3, ..., パ100]
              ↓
        要素を直接変更
              ↓
更新後の配列: [パ1', パ2', パ3', ..., パ100']
              ↑
        同じメモリ領域を使用
```

**処理時間：** ⚡ 速い（メモリ割り当てなし）

### @Observable（遅い）

```
既存の配列: [パ1, パ2, パ3, ..., パ100]
              ↓
        新しい配列を作成（メモリ割り当て）
              ↓
新しい配列: []（空）
              ↓
        100個すべてをコピー
              ↓
新しい配列: [パ1', パ2', パ3', ..., パ100']
              ↓
        古い配列を破棄（ガベージコレクション）
```

**処理時間：** 🐌 遅い（メモリ割り当て + コピー + 破棄）

---

## まとめ

### なぜスローになるのか？

1. **メモリ割り当て**: 毎フレーム新しい配列を作成するため、メモリ割り当てのオーバーヘッドが大きい
2. **データコピー**: 100個のパーティクルを毎フレームコピーするため、処理時間が長い
3. **ガベージコレクション**: 古い配列を頻繁に破棄するため、CPUに負荷がかかる

### ObservableObject + @Published が速い理由

1. **メモリ効率**: 既存の配列を再利用するため、メモリ割り当てが不要
2. **直接変更**: 要素を直接変更するため、コピー処理が不要
3. **低負荷**: ガベージコレクションの負荷が少ない

### 結論

`@Observable`は新しい技術で、一般的には`ObservableObject`より効率的ですが、
**配列の要素を頻繁に更新する場合**（特にアニメーションなど）では、配列全体を再作成する必要があるため、パフォーマンスが低下する可能性があります。

今回の紙吹雪アニメーションのように、**毎フレーム100個のパーティクルを更新する**場合は、`ObservableObject + @Published`の方が適していると言えます。

